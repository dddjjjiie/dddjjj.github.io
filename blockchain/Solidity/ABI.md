# 合约ABI规范

## 函数选择器

合约调用交易data的前四个字节制定了要调用的具体函数，其通过计算keccak-256(function_name(parameter_type_list))，取前四个字节得到

```js
function increaseAge(string name, uint num) returns(uint){
    return ++age;
}

keccak256("increaseAge(string,uint256)")
```

## 编码规范

使用参数a_1，...，a_n调用函数f将会被编码为function_selector(f) enc((a_1，...，a_n))，返回值v_1，...，v_n将会被编码为enc((v_1，...，v_k))

**定义**：以下类型被称为动态的

* bytes
* string
* T[]
* T[k]，T[i]为动态的

其它类型成为静态的

**定义**：len(a)为a的二进制字符串的字节长度，其被定义为uint256

**定义**：对于任意值X，enc(X)为对X的编码，针对不同的X，有以下

* X=(X1,....,Xk)，其中(T1, T2,...Tk)，其中Ti为Xi的类型

  enc(X) = head(X(1))....head(X(k)) tail(X(1))...tail(X(k))，其中head以及tail的定义如下：

  * 如果Ti是静态的，head(X(i)) = enc(X(i))，tail(x(i)) = ""
  * 如果Ti是动态的，head(X(i))=enc(len(head(X(i))...head(X(k)) tail(X(i))...tail(X(i-1))))，tail(X(i))=enc(X(i))

* X=T[k]，enc(X)=enc((X[0], ...., X[k-1]))

* X=T[]，enc(X) = enc(k) enc([X[0],...X[k-1]])

* bytes，enc(X) = enc(k) pad_right(X)

* string，enc(X) = enc(enc_utf8(X))，enc_utf8会将X转化为UTF8的字节编码

* uint\<M\>，enc(X)为在左边补0

* address，类似于uint160

* int\<M\>，对于正数，左边补0，对于负数，左边补1

* bool，当初uint对待，true值为1，false值为0

* bytes\<M\>，右边补0

### 示例

```js
contract Foo {
    function bar(bytes3[2] memory) public pure {}
    function baz(uint32 x, bool y) public pure returns (bool r) { r = x > 32 || y; }
    function sam(bytes memory, bool, uint[] memory) public pure {}
}
```

对于函数baz，hash(baz(uint32,bool))结果为 0xcdcd77c0，对于参数(69，true)编码如下

* 69编码为0x0000000000000000000000000000000000000000000000000000000000000045 
* true编码为 0x0000000000000000000000000000000000000000000000000000000000000001

对于函数bar，hash(bar(bytes3[2]))结果为 0xfce353f6，对于参数("abc", "def")编码如下

* abc编码为0x6162630000000000000000000000000000000000000000000000000000000000 
* def编码为0x6465660000000000000000000000000000000000000000000000000000000000 

对于函数sam，hash(sam(bytes, bool, uint[]))结果为 0xa5643bf2 ，对于参数(dave, true, [1, 2, 3])编码如下

* enc(X) = head(X(1)) head(X(2)) head(X(3)) tail(X(1)) tail(X(2)) tail(X(3))

* head(X(1)) = len(enc( head( X(1) headX(2) headX(3)) )) = 3 * 32Bytes

  0x0000000000000000000000000000000000000000000000000000000000000060 

* head(X(2)) =  0x0000000000000000000000000000000000000000000000000000000000000001

* head(X(3)) =  len(enc( head( X(1) headX(2) headX(3)) tail(X(1)) tail(X(2)) )) = 3 * 32Bytes + 2 * 32Bytes

  0x00000000000000000000000000000000000000000000000000000000000000a0 

* tail(X(1)) = enc(X(1)) = enc(K) enc(X(1)) =

  0x0000000000000000000000000000000000000000000000000000000000000004 

  0x6461766500000000000000000000000000000000000000000000000000000000

* tail(X(2)) = ""

* tail(X(3)) = enc(X(3)) = enc(K) enc(X(3)) = 

  0x0000000000000000000000000000000000000000000000000000000000000003

  0x0000000000000000000000000000000000000000000000000000000000000001

  0x0000000000000000000000000000000000000000000000000000000000000002

  0x0000000000000000000000000000000000000000000000000000000000000003

对于函数g，hash(g(uint\[\]\[\], string[])) 结果为0x2289b18c，对于参数 \(\[\[1, 2\], \[3\]\], \["one", "two", "three"\]\) 编码如下

* enc(X) = head(X(1)) head(X(2)) tail(X(1)) tail(X(2))

* head(X(1)) =  len(enc( head( X(1) headX(2) )) = 2 * 32Byte = 0x40

* head(X(2)) = len(enc( head( X(1) headX(2) tail(X(1)) )) = 0x40 + 32 * 8 = 0x140

* tail(X(1)) = enc(X(1)) = enc(K) enc([[1, 2], 3])

  K

  location([1, 2])，这里的location是指相对于K的偏移，因此location([1, 2]) = 32 * 2 = 0x40

  location(3)，这里的location是指相对于K的偏移，因此location(3) = 32 * 5 = 0xa0

  length([1, 2])

  1

  2

  length(3)

  3

  因此有

  ```js
  0x0000000000000000000000000000000000000000000000000000000000000003
  0x0000000000000000000000000000000000000000000000000000000000000040
  0x00000000000000000000000000000000000000000000000000000000000000a0
  0x0000000000000000000000000000000000000000000000000000000000000002
  0x0000000000000000000000000000000000000000000000000000000000000001
  0x0000000000000000000000000000000000000000000000000000000000000002
  0x0000000000000000000000000000000000000000000000000000000000000001
  0x0000000000000000000000000000000000000000000000000000000000000003
  ```

* tail(X(2)) = enc(X(2)) = enc(K) enc(X(2))

  K

  location("one")，这里的location是指相对于K的偏移，因此location("one") = 32 * 3 = 0x60

  location("two")，这里的location是指相对于K的偏移，因此location("one") = 32 * 5 = 0xA0

  location("three")，这里的location是指相对于K的偏移，因此location("one") = 32 * 3 = 0xE0

  length(enc_utf8("one"))

  enc_utf8("one")

  length(enc_utf8("two"))

  enc_utf8("two")

  length(enc_utf8("three"))

  enc_utf8("three")

  因此有

  ```js
  0x0000000000000000000000000000000000000000000000000000000000000003
  0x0000000000000000000000000000000000000000000000000000000000000060
  0x00000000000000000000000000000000000000000000000000000000000000a0
  0x00000000000000000000000000000000000000000000000000000000000000e0
  0x0000000000000000000000000000000000000000000000000000000000000003
  0x6f6e650000000000000000000000000000000000000000000000000000000000
  0x0000000000000000000000000000000000000000000000000000000000000003
  0x74776f0000000000000000000000000000000000000000000000000000000000
  0x0000000000000000000000000000000000000000000000000000000000000005
  0x7468726565000000000000000000000000000000000000000000000000000000
  ```

## 参考

[Contract ABI Specification](https://docs.soliditylang.org/en/develop/abi-spec.html#indexed-event-encoding)

