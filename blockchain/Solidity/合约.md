# 合约

## 创建合约

合约可以从外部通过交易创建也可以从合约内部创建

当合约被创建后，其构造函数会被执行一次，构造函数最多只能有1个

在构造函数执行后，合约的代码被存储到区块链，这些代码不包含构造函数以及只在构造函数中调用的内部函数

## 可见性与Getters

### 状态变量可见性

* public：编译器会为变量自动生成getter函数，当在合约内使用this.x是调用getter函数来访问，当使用使用x则是直接从storage获取x，由于没有setter函数，其它合约不能直接修改变量值
* internal：只能在当前合约以及子合约访问，是变量的默认可见性
* private：与internal类似，但是子合约不再可以访问变量

### 函数可见性

* external，可以被其它合约或者交易调用，但不能被内部调用(f()不生效，但是this.f()生效)
* public，可以从外部调用也可以被内部调用
* internal，只能从内部调用或者由子合约调用，不能从外部调用
* private，与internal类似，但不能被子合约调用

### Getter函数

编译器会自动为public状态变量创建getter函数

```js
contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public view returns (uint) {
        return c.data();
    }
}
```

getter函数拥有external可见性，如果由内部访问(例如.data)则会访问状态变量，如果由外部访问(例如this.)，则会访问函数

```js
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract C {
    uint public data;
    function x() public returns (uint) {
        data = 3; // internal access
        return this.data(); // external access
    }
}
```

对于一个public的数组，通过getter函数只能访问到单个元素

```js
pragma solidity >=0.4.16 <0.9.0;

contract arrayExample {
    // public state variable
    uint[] public myArray;

    // Getter function generated by the compiler
    /*
    function myArray(uint i) public view returns (uint) {
        return myArray[i];
    }
    */

    // function that returns entire array
    function getArray() public view returns (uint[] memory) {
        return myArray;
    }
}
```

对于mapping也是类似的情况

```js
contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
        uint[3] c;
        uint[] d;
        bytes e;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

function data(uint arg1, bool arg2, uint arg3)
    public
    returns (uint a, bytes3 b, bytes memory e)
{
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
    e = data[arg1][arg2][arg3].e;
}
```

## 函数修饰器

modifier可用于更改函数行为方式

如果想访问合约C的修饰器m，可以使用C.m引用，但只能使用定义在当前合约以及父合约中的修饰器

可以在一个函数中使用多个修饰器，多个修饰器以空格分割，并以列出顺序执行

在函数体中使用return，修饰器中代码仍然会继续执行

在修饰器中使用return;，不影响函数的返回值，如果修饰器不执行函数，则使用return;会返回一个对应类型的默认值

_可以出现多次，所有出现在函数中符号都对修饰器可用，但修饰器中的符号对函数不可见

## 常量和不可变状态变量

对于constant变量，其值必须在编译时就固定，对于immutable变量，其可以在构造函数中赋值

编译器不会为这两种变量保留storage槽，因为其每次出现都会被替换为各自的值

### constant

对于constant变量，赋值表达式不能包含有访问storage、区块链数据、执行时数据、外部合约调用

### Immutable

immutable可以使用任意的值进行赋值，由编译器产生的合约代码会修改合约运行时代码

```js
uint constant X = 32**22 + 8;

contract C {
    string constant TEXT = "abc";
    bytes32 constant MY_HASH = keccak256("abc");
    uint immutable decimals;
    uint immutable maxBalance;
    address immutable owner = msg.sender;

    constructor(uint _decimals, address _reference) {
        decimals = _decimals;
        // Assignments to immutables can even access the environment.
        maxBalance = _reference.balance;
    }

    function isBalanceTooHigh(address _other) public view returns (bool) {
        return _other.balance > maxBalance;
    }
}
```

## 函数

函数也可以定义在合约外，被称为自由函数，其默认可见性为internal，自由函数的代码被包含在调用它们的合约中

自由函数仍是在合约的上下文中执行，在自由函数中仍然可以访问this变量、调用其它合约、发送ether、销毁合约，自由函数与在合约内部的函数的区别是自由函数不能直接访问storage变量和不在它们范围中的函数

```js
function sum(uint[] memory _arr) pure returns (uint s) {
    for (uint i = 0; i < _arr.length; i++)
        s += _arr[i];
}

contract ArrayExample {
    bool found;
    function f(uint[] memory _arr) public {
        // This calls the free function internally.
        // The compiler will add its code to the contract.
        uint s = sum(_arr);
        require(s >= 10);
        found = true;
    }
}
```

### 函数参数和返回变量

#### 函数参数

未命名的函数参数将会被忽略

#### 返回变量

在returns后可以定义返回变量

```js
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint sum, uint product)
    {
        sum = _a + _b;
        product = _a * _b;
    }
}
```

返回变量的名称可以忽略，返回变量可以像其它本地变量一样会被初始化以及使用，在函数中可以直接给返回变量赋值以达到返回值的目的，也可以使用return语句将变量返回

```js
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint sum, uint product)
    {
        return (_a + _b, _a * _b);
    }
}
```

### 状态不变性

#### view函数

view函数保证不会修改状态，其底层使用staticcall来保证，但对于库中的view函数，仍然使用delegatecall，因此库中的view函数不能保证在运行时不会修改状态

以下语句被视为状态修改：

* 写状态变量
* Emitting events
* 创建其它合约
* 使用selfdestruct
* 发送以太
* 调用任何非view或pure函数
* 使用底层调用
* 使用包含操作码的内联汇编

#### pure函数

pure函数保证不会读以及修改状态，特别是在编译期间，只要给定了函数输入和msg.data就可以执行，其底层使用staticcall来保证不能修改数据，但是不能保证状态不能被读取

以下语句被视为读取状态：

* 读取状态变量
* 访问address(this).balance或者address.balance
* 访问block、tx、msg(msg.sig和msg.data)
* 调用任何非pure函数
* 使用了包含操作码的内联汇编

当出现异常时，pure函数可以使用revert和require来回退状态

### 特殊函数

#### receive函数

一个合约最多只有一个receive函数，该函数不能有参数，不能有返回值，必须是external以及payable，其可以是virtual，可以被覆盖，也可以使用函数修饰器

在对合约没有任何附加数据的调用通常是转账交易会触发receive函数，如果没有receive函数，但存在一个payable的回调函数，该回调函数将会用于接收以太币，如果也不存在回调函数则抛出异常

没有receive函数以及payable的回调函数也可以接收出矿奖励以及合约销毁的奖励

```js
contract Sink {
    event Received(address, uint);
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}
```

#### fallback函数

一个合约最多只有一个fallback函数，该函数必须是external，其也可以是virtual，可以被重写，可以使用函数修饰器

当合约中所有函数与data中函数签名不同时会调用fallback函数，当对合约没有任何附加数据的调用且合约中没有receive函数时也会触发fallback函数，但为了接收以太币，fallback函数必须是payable的

```js
fallback() external [payable]
fallback(bytes calldata _input) external [payable] returns (bytes memory _output) //_input与msg.data相同
```

### 函数重载

一个合约可以有多个函数名相同但是参数不同的函数，如果两个external函数的参数类型在solidity中不同，而在外部相同，则会产生编译错误

```js
// This will not compile
contract A {
    function f(B _in) public pure returns (B out) {
        out = _in;
    }

    function f(address _in) public pure returns (address out) {
        out = _in;
    }
}

contract B {
}
```

#### 重载解析和参数匹配

通过匹配函数声明与函数调用中提供的参数来选择重载函数，如果函数调用中参数可以隐士转换为函数声明中的参数，则该函数会被选择为候选函数，如果没有候选函数则解析失败

## 事件

事件可以在合约中继承，事件可以将参数存储在区块链的交易日志中，这些日志与合约地址相关联，但从合约内部无法访问这些日志以及事件数据

可以给最多三个参数添加indexed属性，这会将参数放入到topics数据结构中而不是日志中，一个topic只有一个字(32bytes)，因此给引用类型添加了索引，会存储其keccak-256的哈希值；所有没有indexed标记的参数都以ABI编码存储在日志中

事件的签名也是topic，除非事件被指定为anonymous

## Error和Revert

Errors可以被定义在合约内外(包括接口和库)，其必须和revert使用，Error实例只能通过revert创建

Errors不能被重载以及重写但是可以继承，error通过revert将数据传递给调用者，但只有来自外部调用才能捕获到该异常，来自内部的调用无法捕获到该异常

```js
error InsufficientBalance(uint256 available, uint256 required);

contract TestToken {
    mapping(address => uint) balance;
    function transfer(address to, uint256 amount) public {
        if (amount > balance[msg.sender])
            revert InsufficientBalance({
                available: balance[msg.sender],
                required: amount
            });
        balance[msg.sender] -= amount;
        balance[to] += amount;
    }
    // ...
}
```

## 继承

solidity支持多继承以及多态，多态必须给函数显示指定virtual和override，在合约中可以通过ContractName.functonName()或者super.functionName()调用父合约函数

一个合约继承了其它合约，只有一个合约会在区块链上被创建，被继承合约代码会包含在子合约代码中，这意味着所有对父合约函数的所有内部调用也只是使用内部函数调用(super.f())

子合约只能声明父合约对子合约可见状态变量的不同名状态变量

```js
contract Owned {
    constructor() { owner = payable(msg.sender); }
    address payable owner;
}

contract Destructible is Owned {
    // The keyword `virtual` means that the function can change
    // its behaviour in derived classes ("overriding").
    function destroy() virtual public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

abstract contract Config {
    function lookup(uint id) public virtual returns (address adr);
}


abstract contract NameReg {
    function register(bytes32 name) public virtual;
    function unregister() public virtual;
}

contract Named is Owned, Destructible {
    constructor(bytes32 name) {
        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
        NameReg(config.lookup(1)).register(name);
    }

    function destroy() public virtual override {
        if (msg.sender == owner) {
            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
            NameReg(config.lookup(1)).unregister();

            Destructible.destroy();
        }
    }
}

contract PriceFeed is Owned, Destructible, Named("GoldFeed") {
    function updateInfo(uint newInfo) public {
        if (msg.sender == owner) info = newInfo;
    }

    function destroy() public override(Destructible, Named) { Named.destroy(); }
    function get() public view returns(uint r) { return info; }

    uint info;
}
```

其中Named中Destructible.destroy()调用了父合约的destroy()函数

```js
contract owned {
    constructor() { owner = payable(msg.sender); }
    address payable owner;
}

contract Destructible is owned {
    function destroy() public virtual {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

contract Base1 is Destructible {
    function destroy() public virtual override { /* do cleanup 1 */ Destructible.destroy(); }
}

contract Base2 is Destructible {
    function destroy() public virtual override { /* do cleanup 2 */ Destructible.destroy(); }
}

contract Final is Base1, Base2 {
    function destroy() public override(Base1, Base2) { Base2.destroy(); }
}
```

其中Final.destroy()函数中只调用了Base2.destroy()函数而不会调用Base1.destroy()函数，要想调用Base1.destroy()函数以及Base2.destroy()函数可以使用super

```js
contract owned {
    constructor() { owner = payable(msg.sender); }
    address payable owner;
}

contract Destructible is owned {
    function destroy() virtual public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

contract Base1 is Destructible {
    function destroy() public virtual override { /* do cleanup 1 */ super.destroy(); }
}

contract Base2 is Destructible {
    function destroy() public virtual override { /* do cleanup 2 */ super.destroy(); }
}

contract Final is Base1, Base2 {
    function destroy() public override(Base1, Base2) { super.destroy(); }
}
```

### 函数重写

被重写函数必须是virtual的，重写函数可以将被重写函数的可见性从external变为public，但重写函数的不变性要比被重写函数的不变性更加严格，nonpayable可以被重写为view、pure，view可以被重写为pure，payable不能被重写

```js
contract Base
{
    function foo() virtual external view {}
}

contract Middle is Base {}

contract Inherited is Middle
{
    function foo() override public pure {}
}
```

对于多继承，如果要重写函数必须指定override，如果多个父合约都有相同的函数，在重写时必须在override后指定重写的父合约

```js
contract Base1
{
    function foo() virtual public {}
}

contract Base2
{
    function foo() virtual public {}
}

contract Inherited is Base1, Base2
{
    // Derives from multiple bases defining foo(), so we must explicitly
    // override it
    function foo() public override(Base1, Base2) {}
}
```

公开状态变量(getter)可以重写父合约中拥有同函数名、参数、返回类型的函数

```JS
contract A
{
    function f() external view virtual returns(uint) { return 5; }
}

contract B is A
{
    uint public override f;
}
```

### 修饰器重写

函数修饰器可以重写但不可以重载，virtual必须修饰被重写修饰器，override必须修饰重写修饰器

```js
contract Base
{
    modifier foo() virtual {_;}
}

contract Inherited is Base
{
    modifier foo() override {_;}
}
```

在多继承中，所有直接父合约必须被显示指定

```js
contract Base1
{
    modifier foo() virtual {_;}
}

contract Base2
{
    modifier foo() virtual {_;}
}

contract Inherited is Base1, Base2
{
    modifier foo() override(Base1, Base2) {_;}
}
```

### 构造函数

当合约创建后会执行构造函数，在构造函数执行后合约代码会被部署到区块链上，这些代码不会包含构造函数以及只被构造函数调用的内部函数

一个合约可以有一个构造函数，当没有显示指明构造函数时默认会有一个空的构造函数

```js
abstract contract A {
    uint public a;

    constructor(uint _a) {
        a = _a;
    }
}

contract B is A(1) {
    constructor() {}
}
```

### 构造函数参数

父合约构造函数参数，子合约有两种方式指定所有参数，如果子合约不指定参数，则该子合约变为抽象合约

```js
abstract contract A {
    uint public a;

    constructor(uint _a) {
        a = _a;
    }
}

contract B is A(1) {
    constructor() {}
}
```

### 多继承和线性化

solidity支持多继承，使用C3线性化来指定调用的重写函数，is后父类的书写应该从基类到派生类，而方法的调用是则是从右到左使用深度遍历

```js
contract X {}
contract A is X {}
// This will not compile
contract C is A, X {} //编译错误,X是基类应该放在左边,A为派生类应放在右边
```

多继承中基类构造函数是使用线性方法来初始化的(深度优先遍历)

```js
contract Base1 {
    constructor() {}
}

contract Base2 {
    constructor() {}
}

// Constructors are executed in the following order:
//  1 - Base1
//  2 - Base2
//  3 - Derived1
contract Derived1 is Base1, Base2 {
    constructor() Base1() Base2() {}
}

// Constructors are executed in the following order:
//  1 - Base2
//  2 - Base1
//  3 - Derived2
contract Derived2 is Base2, Base1 {
    constructor() Base2() Base1() {}
}

// Constructors are still executed in the following order:
//  1 - Base2
//  2 - Base1
//  3 - Derived3
contract Derived3 is Base2, Base1 {
    constructor() Base1() Base2() {}
}
```

## 抽象合约

含抽象方法的合约必须声明为抽象合约，但抽象合约可以不包含抽象方法，如果子合约没有实现父抽象合约的所有方法，那么子合约也必须声明为一个抽象方法

```js
abstract contract Feline {
    function utterance() public pure virtual returns (bytes32);
}

contract Cat is Feline {
    function utterance() public pure override returns (bytes32) { return "miaow"; }
}

function foo(address) external returns (address); //抽象函数
function(address) external returns (address) foo; //函数变量
```

## 接口

接口与抽象合约类似，但更加严格：

* 不能继承其它合约，但能继承其它接口
* 所有函数必须是external的
* 不能声明构造函数
* 不能声明状态变量
* 不能声明修饰器

接口中所有声明的函数默认为virtual，并且重写这些函数不需要使用override

```js
interface ParentA {
    function test() external returns (uint256);
}

interface ParentB {
    function test() external returns (uint256);
}

interface SubInterface is ParentA, ParentB {
    // Must redefine test in order to assert that the parent
    // meanings are compatible.
    function test() external override(ParentA, ParentB) returns (uint256);
}
```

## 库

库一旦部署，其代码可以通过DELEGATECALL重复使用，库的执行是在调用合约的上下文中执行，this指的是调用合约。如果库函数不修改状态(view、pure)，那么可以不使用DELEGATECALL直接调用

库可以被看成是调用该库合约的隐士父合约

## 参考

[Contracts](https://docs.soliditylang.org/en/develop/contracts.html#)

