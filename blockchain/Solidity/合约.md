# 合约

## 创建合约

合约可以从外部通过交易创建也可以从合约内部创建

当合约被创建后，其构造函数会被执行一次，构造函数最多只能有1个

在构造函数执行后，合约的代码被存储到区块链，这些代码不包含构造函数以及只在构造函数中调用的内部函数

## 可见性与Getters

### 状态变量可见性

* public：编译器会为变量自动生成getter函数，当在合约内使用this.x是调用getter函数来访问，当使用使用x则是直接从storage获取x，由于没有setter函数，其它合约不能直接修改变量值
* internal：只能在当前合约以及子合约访问，是变量的默认可见性
* private：与internal类似，但是子合约不再可以访问变量

### 函数可见性

* external，可以被其它合约或者交易调用，但不能被内部调用(f()不生效，但是this.f()生效)
* public，可以从外部调用也可以被内部调用
* internal，只能从内部调用或者由子合约调用，不能从外部调用
* private，与internal类似，但不能被子合约调用

### Getter函数

编译器会自动为public状态变量创建getter函数

```js
contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public view returns (uint) {
        return c.data();
    }
}
```

getter函数拥有external可见性，如果由内部访问(例如.data)则会访问状态变量，如果由外部访问(例如this.)，则会访问函数

```js
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract C {
    uint public data;
    function x() public returns (uint) {
        data = 3; // internal access
        return this.data(); // external access
    }
}
```

对于一个public的数组，通过getter函数只能访问到单个元素

```js
pragma solidity >=0.4.16 <0.9.0;

contract arrayExample {
    // public state variable
    uint[] public myArray;

    // Getter function generated by the compiler
    /*
    function myArray(uint i) public view returns (uint) {
        return myArray[i];
    }
    */

    // function that returns entire array
    function getArray() public view returns (uint[] memory) {
        return myArray;
    }
}
```

对于mapping也是类似的情况

```js
contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
        uint[3] c;
        uint[] d;
        bytes e;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

function data(uint arg1, bool arg2, uint arg3)
    public
    returns (uint a, bytes3 b, bytes memory e)
{
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
    e = data[arg1][arg2][arg3].e;
}
```

## 函数修饰器

modifier可用于更改函数行为方式

如果想访问合约C的修饰器m，可以使用C.m引用，但只能使用定义在当前合约以及父合约中的修饰器

可以在一个函数中使用多个修饰器，多个修饰器以空格分割，并以列出顺序执行

在函数体中使用return，修饰器中代码仍然会继续执行

在修饰器中使用return;，不影响函数的返回值，如果修饰器不执行函数，则使用return;会返回一个对应类型的默认值

_可以出现多次，所有出现在函数中符号都对修饰器可用，但修饰器中的符号对函数不可见

## 常量和不可变状态变量

对于constant变量，其值必须在编译时就固定，对于immutable变量，其可以在构造函数中赋值

编译器不会为这两种变量保留storage槽，因为其每次出现都会被替换为各自的值

### constant

对于constant变量，赋值表达式不能包含有访问storage、区块链数据、执行时数据、外部合约调用

### Immutable

immutable可以使用任意的值进行赋值，由编译器产生的合约代码会修改合约运行时代码

```js
uint constant X = 32**22 + 8;

contract C {
    string constant TEXT = "abc";
    bytes32 constant MY_HASH = keccak256("abc");
    uint immutable decimals;
    uint immutable maxBalance;
    address immutable owner = msg.sender;

    constructor(uint _decimals, address _reference) {
        decimals = _decimals;
        // Assignments to immutables can even access the environment.
        maxBalance = _reference.balance;
    }

    function isBalanceTooHigh(address _other) public view returns (bool) {
        return _other.balance > maxBalance;
    }
}
```

## 函数

函数也可以定义在合约外，被称为自由函数，其默认可见性为internal，自由函数的代码被包含在调用它们的合约中

自由函数仍是在合约的上下文中执行，在自由函数中仍然可以访问this变量、调用其它合约、发送ether、销毁合约，自由函数与在合约内部的函数的区别是自由函数不能直接访问storage变量和不在它们范围中的函数

```js
function sum(uint[] memory _arr) pure returns (uint s) {
    for (uint i = 0; i < _arr.length; i++)
        s += _arr[i];
}

contract ArrayExample {
    bool found;
    function f(uint[] memory _arr) public {
        // This calls the free function internally.
        // The compiler will add its code to the contract.
        uint s = sum(_arr);
        require(s >= 10);
        found = true;
    }
}
```

### 函数参数和返回变量

#### 函数参数

未命名的函数参数将会被忽略

#### 返回变量

在returns后可以定义返回变量

```js
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint sum, uint product)
    {
        sum = _a + _b;
        product = _a * _b;
    }
}
```

返回变量的名称可以忽略，返回变量可以像其它本地变量一样会被初始化以及使用，在函数中可以直接给返回变量赋值以达到返回值的目的，也可以使用return语句将变量返回

```js
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint sum, uint product)
    {
        return (_a + _b, _a * _b);
    }
}
```

### 状态不变性

#### view函数

view函数保证不会修改状态，其底层使用staticcall来保证，但对于库中的view函数，仍然使用delegatecall，因此库中的view函数不能保证在运行时不会修改状态

以下语句被视为状态修改：

* 写状态变量
* Emitting events
* 创建其它合约
* 使用selfdestruct
* 发送以太
* 调用任何非view或pure函数
* 使用底层调用
* 使用包含操作码的内联汇编

#### pure函数

pure函数保证不会读以及修改状态，特别是在编译期间，只要给定了函数输入和msg.data就可以执行，其底层使用staticcall来保证不能修改数据，但是不能保证状态不能被读取

以下语句被视为读取状态：

* 读取状态变量
* 访问address(this).balance或者address.balance
* 访问block、tx、msg(msg.sig和msg.data)
* 调用任何非pure函数
* 使用了包含操作码的内联汇编

当出现异常时，pure函数可以使用revert和require来回退状态

### 特殊函数

#### receive函数

一个合约最多只有一个receive函数，该函数不能有参数，不能有返回值，必须是external以及payable，其可以是virtual，可以被覆盖，也可以使用函数修饰器

在对合约没有任何附加数据的调用通常是转账交易会触发receive函数，如果没有receive函数，但存在一个payable的回调函数，该回调函数将会用于接收以太币，如果也不存在回调函数则抛出异常

没有receive函数以及payable的回调函数也可以接收出矿奖励以及合约销毁的奖励

```js
contract Sink {
    event Received(address, uint);
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}
```

#### fallback函数

一个合约最多只有一个fallback函数，该函数必须是external，其也可以是virtual，可以被重写，可以使用函数修饰器

当合约中所有函数与data中函数签名不同时会调用fallback函数，当对合约没有任何附加数据的调用且合约中没有receive函数时也会触发fallback函数，但为了接收以太币，fallback函数必须是payable的

```js
fallback() external [payable]
fallback(bytes calldata _input) external [payable] returns (bytes memory _output) //_input与msg.data相同
```

### 函数重载

一个合约可以有多个函数名相同但是参数不同的函数，如果两个external函数的参数类型在solidity中不同，而在外部相同，则会产生编译错误

```js
// This will not compile
contract A {
    function f(B _in) public pure returns (B out) {
        out = _in;
    }

    function f(address _in) public pure returns (address out) {
        out = _in;
    }
}

contract B {
}
```

#### 重载解析和参数匹配

通过匹配函数声明与函数调用中提供的参数来选择重载函数，如果函数调用中参数可以隐士转换为函数声明中的参数，则该函数会被选择为候选函数，如果没有候选函数则解析失败

## 事件

事件可以在合约中继承，事件可以将参数存储在区块链的交易日志中，这些日志与合约地址相关联，但从合约内部无法访问这些日志以及事件数据

可以给最多三个参数添加indexed属性，这会将参数放入到topics数据结构中而不是日志中，一个topic只有一个字(32bytes)，因此给引用类型添加了索引，会存储其keccak-256的哈希值；所有没有indexed标记的参数都以ABI编码存储在日志中

事件的签名也是topic，除非事件被指定为anonymous

